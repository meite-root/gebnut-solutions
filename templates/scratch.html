<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scratch-off</title>

  <style>
    :root{
      --bg: #2a0b12;
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.72);
      --shadow: 0 18px 55px rgba(0,0,0,0.55);
      --ring: rgba(255,255,255,0.18);
    }
    *{ box-sizing:border-box; }
    html,body{
      margin:0; padding:0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }

    /* subtle patterned background vibe (like the reference) */
    .bg{
      min-height: 100vh;
      background:
        radial-gradient(circle at 25% 10%, rgba(255,255,255,0.07), transparent 40%),
        radial-gradient(circle at 70% 30%, rgba(255,255,255,0.06), transparent 45%),
        repeating-linear-gradient(45deg,
          rgba(255,255,255,0.04) 0px,
          rgba(255,255,255,0.04) 12px,
          rgba(0,0,0,0.00) 12px,
          rgba(0,0,0,0.00) 28px
        ),
        linear-gradient(180deg, rgba(0,0,0,0.16), rgba(0,0,0,0.20));
    }

    .wrap{
      max-width: 760px;
      margin: 0 auto;
      padding: 54px 18px 70px;
      text-align:center;
    }

    .brand{
      letter-spacing: 0.10em;
      text-transform: uppercase;
      font-weight: 800;
      font-size: 44px;
      margin: 0;
      opacity: 0.92;
    }
    .subtitle{
      margin: 10px 0 0;
      color: var(--muted);
      font-weight: 600;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      font-size: 14px;
    }
    .title2{
      margin: 6px 0 30px;
      color: rgba(255,255,255,0.78);
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-size: 18px;
    }

    .disk-area{
      display:flex;
      justify-content:center;
      margin: 18px 0 18px;
    }

    /* The circular scratch ‚Äúcoin‚Äù */
    .scratch-disk{
      position: relative;
      width: min(78vw, 420px);
      aspect-ratio: 1 / 1;
      border-radius: 50%;
      overflow: hidden;
      box-shadow: var(--shadow);
      border: 1px solid var(--ring);
      background: rgba(0,0,0,0.22);
    }

    /* prize is behind */
    .scratch-disk img{
      width: 100%;
      height: 100%;
      object-fit: cover;
      display:block;
      user-select: none;
      -webkit-user-drag: none;
      filter: saturate(1.03) contrast(1.02);
    }

    /* canvas sits on top */
    #scratch{
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display:block;
      touch-action: none;
      cursor: pointer;
    }

    .below{
      margin-top: 16px;
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 12px;
      flex-wrap: wrap;
      color: var(--muted);
      font-size: 13px;
    }

    .pill{
      display:inline-flex;
      gap:10px;
      align-items:center;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      box-shadow: 0 12px 25px rgba(0,0,0,0.25);
    }

    .btn{
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.20);
      background: rgba(255,255,255,0.10);
      color: rgba(255,255,255,0.92);
      cursor: pointer;
      font-weight: 650;
      letter-spacing: 0.02em;
    }
    .btn:hover{ background: rgba(255,255,255,0.14); }

    .msg{
      margin-top: 14px;
      display:none;
      color: rgba(255,255,255,0.90);
      font-weight: 650;
    }
    .msg.show{ display:block; }

    .links{
      margin-top: 26px;
      color: rgba(255,255,255,0.65);
      font-size: 13px;
    }
    .links a{ color: rgba(255,255,255,0.72); text-decoration:none; }
    .links a:hover{ text-decoration:underline; }
  </style>
</head>

<body>
  <div class="bg">
    <div class="wrap">
      <h1 class="brand">CLIENT NAME</h1>
      <div class="subtitle">Customer engagement</div>
      <div class="title2">Scratch-off game</div>

      <div class="disk-area">
        <div class="scratch-disk" aria-label="Scratch to reveal">
          <!-- Prize image underneath -->
          <img id="prizeImg" src="/static/scratch/prize.png" alt="Prize" />
          <!-- Canvas overlay on top -->
          <canvas id="scratch"></canvas>
        </div>
      </div>

      <div id="revealMsg" class="msg">üéÅ Revealed!</div>

      <div class="below">
        <div class="pill">
          <span id="progressText">0% revealed</span>
        </div>
        <button class="btn" id="resetBtn" type="button">Reset</button>
      </div>

      <div class="links">
        <a href="#">Rules, Terms, and Conditions</a>
        &nbsp;&nbsp;‚Ä¢&nbsp;&nbsp;
        <a href="#">Privacy</a>
        &nbsp;&nbsp;‚Ä¢&nbsp;&nbsp;
        <span>¬© <span id="year"></span> Geb &amp; Nut</span>
      </div>

    </div>
  </div>

  <script>
    (function(){
      const canvas = document.getElementById("scratch");
      const img = document.getElementById("prizeImg");
      const resetBtn = document.getElementById("resetBtn");
      const progressText = document.getElementById("progressText");
      const revealMsg = document.getElementById("revealMsg");

      const ctx = canvas.getContext("2d", { willReadFrequently: true });

      // ===== tuning =====
      const BRUSH_RADIUS = 22;        // scratch size
      const REVEAL_THRESHOLD = 0.80;  // 80%
      const LOCK_AFTER_REVEAL = true; // set false if you want scratching to continue

      // ===== overlay asset (Option A) =====
      const METAL_IMAGE_URL = "/static/scratch/metal.png";
      const metalImg = new Image();
      metalImg.src = METAL_IMAGE_URL;

      let isDown = false;
      let lastPoint = null;
      let revealed = false;

      function resizeCanvasToDisplaySize(){
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        const w = Math.max(1, Math.floor(rect.width * dpr));
        const h = Math.max(1, Math.floor(rect.height * dpr));
        if (canvas.width !== w || canvas.height !== h) {
          canvas.width = w;
          canvas.height = h;
        }
        // draw in CSS pixels
        ctx.setTransform(1,0,0,1,0,0);
        ctx.scale(dpr, dpr);
      }

      function drawLabel(rect){
        // This text is printed ON the overlay, so it scratches off too.
        ctx.save();
        ctx.globalCompositeOperation = "source-over";

        // subtle shadow
        ctx.fillStyle = "rgba(0,0,0,0.18)";
        ctx.font = "800 28px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("SCRATCH", rect.width/2 + 1, rect.height/2 - 22 + 1);
        ctx.fillText("HERE", rect.width/2 + 1, rect.height/2 + 22 + 1);

        // main text
        ctx.fillStyle = "rgba(0,0,0,0.78)";
        ctx.fillText("SCRATCH", rect.width/2, rect.height/2 - 22);
        ctx.fillText("HERE", rect.width/2, rect.height/2 + 22);

        ctx.restore();
      }

      // Option B: generate ‚Äúmetal‚Äù if image is missing
      function drawGeneratedMetal(rect){
        // base
        const g = ctx.createRadialGradient(
          rect.width * 0.35, rect.height * 0.35, rect.width * 0.10,
          rect.width * 0.55, rect.height * 0.55, rect.width * 0.75
        );
        g.addColorStop(0.0, "#f0f0f0");
        g.addColorStop(0.25, "#cfcfcf");
        g.addColorStop(0.55, "#9f9f9f");
        g.addColorStop(0.78, "#d6d6d6");
        g.addColorStop(1.0, "#8f8f8f");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, rect.width, rect.height);

        // angled highlight band
        ctx.save();
        ctx.globalAlpha = 0.35;
        ctx.translate(rect.width/2, rect.height/2);
        ctx.rotate(-0.55);
        ctx.translate(-rect.width/2, -rect.height/2);

        const band = ctx.createLinearGradient(0, rect.height*0.35, rect.width, rect.height*0.65);
        band.addColorStop(0, "rgba(255,255,255,0.0)");
        band.addColorStop(0.5, "rgba(255,255,255,0.65)");
        band.addColorStop(1, "rgba(255,255,255,0.0)");
        ctx.fillStyle = band;
        ctx.fillRect(-rect.width, rect.height*0.15, rect.width*3, rect.height*0.7);

        ctx.restore();

        // slight vignette edge to feel ‚Äúcoin-like‚Äù
        ctx.save();
        ctx.globalAlpha = 0.25;
        const v = ctx.createRadialGradient(rect.width/2, rect.height/2, rect.width*0.25, rect.width/2, rect.height/2, rect.width*0.55);
        v.addColorStop(0, "rgba(0,0,0,0)");
        v.addColorStop(1, "rgba(0,0,0,0.55)");
        ctx.fillStyle = v;
        ctx.fillRect(0,0,rect.width,rect.height);
        ctx.restore();
      }

      function drawOverlay(){
        const rect = canvas.getBoundingClientRect();
        ctx.globalCompositeOperation = "source-over";
        ctx.clearRect(0,0,rect.width,rect.height);

        // Draw the metallic overlay (image if available, else generated)
        if (metalImg.complete && metalImg.naturalWidth > 0) {
          // cover fill
          ctx.drawImage(metalImg, 0, 0, rect.width, rect.height);
        } else {
          drawGeneratedMetal(rect);
        }

        // Print label on top of metal (scratches off)
        drawLabel(rect);

        // Switch into erase mode for scratching
        ctx.globalCompositeOperation = "destination-out";

        // reset UI state
        revealed = false;
        revealMsg.classList.remove("show");
        progressText.textContent = "0% revealed";
      }

      function getPoint(e){
        const rect = canvas.getBoundingClientRect();
        const p = (e.touches && e.touches[0]) ? e.touches[0] : e;
        return { x: p.clientX - rect.left, y: p.clientY - rect.top };
      }

      function scratchLine(from, to){
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.strokeStyle = "rgba(0,0,0,1)";
        ctx.lineWidth = BRUSH_RADIUS * 2;

        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
      }

      function scratchDot(p){
        ctx.beginPath();
        ctx.arc(p.x, p.y, BRUSH_RADIUS, 0, Math.PI * 2);
        ctx.fill();
      }

      function estimateRevealed(){
        const rect = canvas.getBoundingClientRect();
        const w = Math.floor(rect.width);
        const h = Math.floor(rect.height);

        const imgData = ctx.getImageData(0, 0, w, h).data;
        let cleared = 0;
        const total = imgData.length / 4;

        for (let i = 3; i < imgData.length; i += 4) {
          if (imgData[i] < 20) cleared++;
        }

        const ratio = cleared / total;
        progressText.textContent = Math.round(ratio * 100) + "% revealed";

        if (!revealed && ratio >= REVEAL_THRESHOLD) {
          revealed = true;
          revealMsg.classList.add("show");
        }
      }

      function onDown(e){
        if (LOCK_AFTER_REVEAL && revealed) return;
        isDown = true;
        lastPoint = getPoint(e);
        scratchDot(lastPoint);
        estimateRevealed();
      }

      function onMove(e){
        if (!isDown) return;
        if (LOCK_AFTER_REVEAL && revealed) return;

        const p = getPoint(e);
        scratchLine(lastPoint, p);
        lastPoint = p;

        // no randomness
        estimateRevealed();
      }

      function onUp(){
        if (!isDown) return;
        isDown = false;
        lastPoint = null;
        estimateRevealed();
      }

      function init(){
        resizeCanvasToDisplaySize();
        drawOverlay();

        canvas.addEventListener("mousedown", onDown);
        window.addEventListener("mousemove", onMove);
        window.addEventListener("mouseup", onUp);

        canvas.addEventListener("touchstart", (e) => { e.preventDefault(); onDown(e); }, { passive:false });
        canvas.addEventListener("touchmove", (e) => { e.preventDefault(); onMove(e); }, { passive:false });
        canvas.addEventListener("touchend", (e) => { e.preventDefault(); onUp(e); }, { passive:false });

        resetBtn.addEventListener("click", () => {
          resizeCanvasToDisplaySize();
          drawOverlay();
        });

        window.addEventListener("resize", () => {
          resizeCanvasToDisplaySize();
          drawOverlay();
        });
      }

      // Wait for both images to settle; we can init once prize is loaded
      if (img.complete) init();
      else img.addEventListener("load", init);

      // If metal loads after init, redraw overlay so it uses the PNG instead of fallback
      metalImg.addEventListener("load", () => {
        resizeCanvasToDisplaySize();
        drawOverlay();
      });
    })();
  </script>
  <script>
    document.getElementById("year").textContent = new Date().getFullYear();
  </script>

</body>
</html>
