<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scratch to Reveal</title>

  <style>
    :root{
      --bg: #0b0d12;
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);
      --line: rgba(255,255,255,0.12);
      --panel: rgba(255,255,255,0.05);
      --shadow: 0 18px 45px rgba(0,0,0,0.45);
    }

    *{ box-sizing:border-box; }
    html,body{ margin:0; padding:0; background:var(--bg); color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }

    a{ color:inherit; }

    .scratch-wrap{
      max-width: 560px;
      margin: 0 auto;
      padding: 56px 18px;
    }

    .scratch-card{
      border: 1px solid var(--line);
      border-radius: 18px;
      overflow: hidden;
      background: rgba(255,255,255,0.035);
      box-shadow: var(--shadow);
    }

    .scratch-head{
      padding: 18px 18px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
    }

    .scratch-head h1{
      font-size: 22px;
      margin: 0 0 6px;
    }

    .scratch-head p{
      margin: 0;
      color: var(--muted);
      line-height: 1.5;
    }

    .scratch-stage{
      position: relative;
      aspect-ratio: 1.6 / 1;
      background: rgba(0,0,0,0.15);
    }

    .scratch-stage img{
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      user-select: none;
      -webkit-user-drag: none;
    }

    canvas#scratch{
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none; /* important for mobile */
      cursor: crosshair;
    }

    .reveal-message{
      padding: 12px 18px 0;
      color: rgba(255,255,255,0.86);
      display:none;
    }
    .reveal-message.show{ display:block; }

    .scratch-footer{
      display:flex;
      gap: 10px;
      align-items:center;
      justify-content: space-between;
      padding: 14px 18px 18px;
      border-top: 1px solid rgba(255,255,255,0.10);
      color: var(--muted);
      font-size: 13px;
    }

    .badge{
      display:inline-flex;
      gap:8px;
      align-items:center;
    }
    .dot{
      width: 8px; height: 8px; border-radius: 999px;
      background: rgba(255,255,255,0.45);
    }

    .mini-btn{
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.9);
      cursor: pointer;
    }
    .mini-btn:hover{ background: rgba(255,255,255,0.10); }
  </style>
</head>

<body>
  <div class="scratch-wrap">
    <div class="scratch-card">
      <div class="scratch-head">
        <h1>Scratch to reveal your prize</h1>
        <p>Scratch the gray area to uncover what you‚Äôre about to win.</p>
      </div>

      <div class="scratch-stage">
        <!-- Prize image underneath -->
        <img id="prizeImg" src="/static/products/umbrella.jpg" alt="Prize image" />
        <!-- Gray overlay canvas on top -->
        <canvas id="scratch" aria-label="Scratch area"></canvas>
      </div>

      <div id="revealMsg" class="reveal-message">
        üéÅ Revealed!
      </div>

      <div class="scratch-footer">
        <span class="badge">
          <span class="dot"></span>
          <span id="progressText">0% revealed</span>
        </span>
        <button class="mini-btn" id="resetBtn" type="button">Reset</button>
      </div>
    </div>
  </div>

  <script>
    (function(){
      const canvas = document.getElementById("scratch");
      const img = document.getElementById("prizeImg");
      const resetBtn = document.getElementById("resetBtn");
      const progressText = document.getElementById("progressText");
      const revealMsg = document.getElementById("revealMsg");

      const ctx = canvas.getContext("2d", { willReadFrequently: true });

      // ===== Feel tuning =====
      const BRUSH_RADIUS = 22;        // scratch size
      const REVEAL_THRESHOLD = 0.10;  // 10%

      let isDown = false;
      let lastPoint = null;
      let revealed = false;

      function resizeCanvasToDisplaySize(){
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;

        const w = Math.max(1, Math.floor(rect.width * dpr));
        const h = Math.max(1, Math.floor(rect.height * dpr));

        if (canvas.width !== w || canvas.height !== h) {
          canvas.width = w;
          canvas.height = h;
        }

        // draw in CSS pixels
        ctx.setTransform(1,0,0,1,0,0);
        ctx.scale(dpr, dpr);
      }

      function drawOverlay(){
        const rect = canvas.getBoundingClientRect();

        ctx.globalCompositeOperation = "source-over";

        // classy gray overlay (slight gradient)
        const g = ctx.createLinearGradient(0, 0, rect.width, rect.height);
        g.addColorStop(0, "rgba(255,255,255,0.32)");
        g.addColorStop(1, "rgba(255,255,255,0.18)");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, rect.width, rect.height);

        // label
        ctx.fillStyle = "rgba(0,0,0,0.22)";
        ctx.font = "600 18px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("SCRATCH HERE", rect.width/2, rect.height/2);

        // switch into erase mode for scratching
        ctx.globalCompositeOperation = "destination-out";

        // reset UI
        revealed = false;
        revealMsg.classList.remove("show");
        progressText.textContent = "0% revealed";
      }

      function getPoint(e){
        const rect = canvas.getBoundingClientRect();
        const p = (e.touches && e.touches[0]) ? e.touches[0] : e;
        return { x: p.clientX - rect.left, y: p.clientY - rect.top };
      }

      function scratchLine(from, to){
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.strokeStyle = "rgba(0,0,0,1)";
        ctx.lineWidth = BRUSH_RADIUS * 2;

        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
      }

      function scratchDot(p){
        ctx.beginPath();
        ctx.arc(p.x, p.y, BRUSH_RADIUS, 0, Math.PI * 2);
        ctx.fill();
      }

      function estimateRevealed(){
        const rect = canvas.getBoundingClientRect();

        // IMPORTANT: use the canvas pixel size for reading, but we scaled drawing to CSS pixels.
        // Since we scaled ctx with dpr, rect.width/height correspond to CSS pixels, which matches our draw coords.
        const w = Math.floor(rect.width);
        const h = Math.floor(rect.height);

        const imgData = ctx.getImageData(0, 0, w, h).data;

        let cleared = 0;
        const total = imgData.length / 4;

        for (let i = 3; i < imgData.length; i += 4) {
          if (imgData[i] < 20) cleared++;
        }

        const ratio = cleared / total;
        const pct = Math.round(ratio * 100);
        progressText.textContent = pct + "% revealed";

        if (!revealed && ratio >= REVEAL_THRESHOLD) {
          revealed = true;
          revealMsg.classList.add("show");
        }
      }

      function onDown(e){
        if (revealed) return; // optional: stop interaction after reveal
        isDown = true;
        lastPoint = getPoint(e);
        scratchDot(lastPoint);
        estimateRevealed();
      }

      function onMove(e){
        if (!isDown || revealed) return;
        const p = getPoint(e);
        scratchLine(lastPoint, p);
        lastPoint = p;
        estimateRevealed(); // no randomness
      }

      function onUp(){
        if (!isDown) return;
        isDown = false;
        lastPoint = null;
        estimateRevealed();
      }

      function init(){
        resizeCanvasToDisplaySize();
        drawOverlay();

        canvas.addEventListener("mousedown", onDown);
        window.addEventListener("mousemove", onMove);
        window.addEventListener("mouseup", onUp);

        canvas.addEventListener("touchstart", (e) => { e.preventDefault(); onDown(e); }, { passive:false });
        canvas.addEventListener("touchmove", (e) => { e.preventDefault(); onMove(e); }, { passive:false });
        canvas.addEventListener("touchend", (e) => { e.preventDefault(); onUp(e); }, { passive:false });

        resetBtn.addEventListener("click", () => {
          resizeCanvasToDisplaySize();
          drawOverlay();
        });

        window.addEventListener("resize", () => {
          resizeCanvasToDisplaySize();
          drawOverlay();
        });
      }

      if (img.complete) init();
      else img.addEventListener("load", init);
    })();
  </script>
</body>
</html>
